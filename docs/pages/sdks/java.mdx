# Java SDK

The T402 Java SDK provides a complete implementation of the t402 payment protocol for Java applications, with first-class support for Spring Boot and multi-chain payments.

[![Maven Central](https://img.shields.io/maven-central/v/io.t402/t402?label=maven%20central)](https://central.sonatype.com/artifact/io.t402/t402)

## Installation

import { Tabs } from 'nextra/components'

<Tabs items={['Maven', 'Gradle']}>
<Tabs.Tab>
```xml
<dependency>
    <groupId>io.t402</groupId>
    <artifactId>t402</artifactId>
    <version>1.1.0</version>
</dependency>
```
</Tabs.Tab>
<Tabs.Tab>
```groovy
implementation 'io.t402:t402:1.1.0'
```
</Tabs.Tab>
</Tabs>

## Features

| Feature | Status |
|---------|--------|
| Core Client | ✅ |
| Core Server | ✅ |
| Facilitator Client | ✅ |
| EVM Mechanism | ✅ |
| SVM Mechanism (Solana) | ✅ |
| TON Mechanism | ✅ |
| TRON Mechanism | ✅ |
| ERC-4337 Account Abstraction | ✅ |
| USDT0 Cross-Chain Bridge | ✅ |
| WDK Integration | ✅ |
| CLI Tool | ✅ |
| Spring Boot Integration | ✅ |

## Quick Start

### Spring Boot (Recommended)

The easiest way to use T402 in a Spring Boot application is with auto-configuration.

**1. Add configuration to `application.yml`:**

```yaml
t402:
  enabled: true
  facilitator-url: https://facilitator.t402.io
  network: eip155:8453
  pay-to: "0xYourReceiverAddress"
  asset: "0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913"
  token-name: "USD Coin"
  token-version: "2"
```

**2. Create a protected endpoint:**

```java
@RestController
public class ApiController {

    @GetMapping("/api/premium")
    public Map<String, String> premiumContent() {
        // This endpoint is automatically protected
        return Map.of("data", "Premium content!");
    }
}
```

The `PaymentFilter` is automatically registered for `/api/*` endpoints.

### @RequirePayment Annotation (v1.1.0+)

Use annotations for fine-grained payment protection:

```java
import io.t402.spring.RequirePayment;

@RestController
public class ApiController {

    // Protect with annotation - $0.01 per request
    @RequirePayment(amount = "$0.01", description = "Premium API access")
    @GetMapping("/api/premium")
    public Map<String, String> premiumContent() {
        return Map.of("data", "Premium content!");
    }

    // Different price for different endpoints
    @RequirePayment(amount = "1000000", description = "Heavy computation")
    @PostMapping("/api/compute")
    public ComputeResult compute(@RequestBody ComputeRequest request) {
        return computeService.process(request);
    }

    // Class-level annotation applies to all methods
    @RequirePayment(amount = "$0.05")
    @RestController
    @RequestMapping("/api/v2")
    public class V2ApiController {
        // All endpoints require $0.05
    }
}
```

**Amount formats supported:**
- Dollar notation: `"$1.00"`, `"$0.01"`
- Atomic units: `"1000000"` (6 decimals for USDC)
- Decimal notation: `"1.00"`

### Route-Based Configuration (v1.1.0+)

Configure routes via YAML instead of annotations:

```yaml
t402:
  enabled: true
  facilitator-url: https://facilitator.t402.io
  network: eip155:8453
  pay-to: "0xYourAddress"
  routes:
    - path: "GET /api/data"
      amount: "$0.01"
      description: "Data access"
    - path: "POST /api/compute"
      amount: "$0.10"
      description: "Heavy computation"
    - path: "/api/premium/**"
      amount: "$0.05"
      description: "Premium endpoints"
```

### Spring WebFlux (Reactive) (v1.1.0+)

For reactive Spring WebFlux applications:

```java
import io.t402.spring.reactive.PaymentWebFilter;

@Configuration
@EnableWebFlux
public class WebFluxConfig {

    @Bean
    public PaymentWebFilter paymentWebFilter(FacilitatorClient facilitator) {
        return new PaymentWebFilter(facilitator, routeConfigs);
    }
}
```

Or use auto-configuration:

```yaml
t402:
  enabled: true
  webflux: true  # Enable WebFlux support
  facilitator-url: https://facilitator.t402.io
```

### Manual Setup

For non-Spring applications or custom configurations:

```java
import io.t402.server.PaymentFilter;
import io.t402.client.HttpFacilitatorClient;

// Create facilitator client
FacilitatorClient facilitator = new HttpFacilitatorClient(
    "https://facilitator.t402.io"
);

// Create payment filter
PaymentFilter filter = new PaymentFilter(facilitator);

// Register with your servlet container
FilterRegistration.Dynamic registration = servletContext.addFilter("t402", filter);
registration.addMappingForUrlPatterns(
    EnumSet.of(DispatcherType.REQUEST),
    true,
    "/api/*"
);
```

## Multi-Chain Signers

The Java SDK supports multiple blockchain networks with dedicated signers.

### EVM Signer

EIP-3009 TransferWithAuthorization signing for Ethereum and EVM-compatible chains:

```java
import io.t402.crypto.EvmSigner;

// Create EVM signer for USDC on Base
EvmSigner signer = EvmSigner.fromPrivateKey(
    "0xYourPrivateKey",
    8453,                                              // Base chain ID
    "USD Coin",                                        // Token name
    "2",                                               // Token version
    "0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913"       // USDC address
);

// Sign a payment
String signature = signer.sign(paymentPayload);
```

### SVM Signer (Solana)

Ed25519 signing with Base58 encoding for Solana:

```java
import io.t402.crypto.SvmSigner;

// Create from private key bytes
SvmSigner signer = new SvmSigner(privateKeyBytes);

// Or from Base58-encoded private key
SvmSigner signer = SvmSigner.fromBase58("YourBase58PrivateKey");

// Get public key (Base58)
String publicKey = signer.getPublicKey();

// Sign transaction
byte[] signature = signer.sign(transactionBytes);
```

### TON Signer

Ed25519 signing with Base64 encoding for TON:

```java
import io.t402.crypto.TonSigner;

// Create from seed bytes
TonSigner signer = new TonSigner(seedBytes);

// Or from hex-encoded seed
TonSigner signer = TonSigner.fromHex("YourHexSeed");

// Get public key (hex)
String publicKey = signer.getPublicKey();

// Sign message
byte[] signature = signer.sign(messageBytes);
```

### TRON Signer

ECDSA secp256k1 signing with Base58Check encoding for TRON:

```java
import io.t402.crypto.TronSigner;

// Create from private key
TronSigner signer = new TronSigner(privateKeyBytes);

// Or from hex-encoded private key
TronSigner signer = TronSigner.fromHex("YourHexPrivateKey");

// Get TRON address (T...)
String address = signer.getAddress();

// Sign transaction
byte[] signature = signer.sign(transactionBytes);
```

## ERC-4337 Account Abstraction

The SDK includes full support for ERC-4337 v0.7 gasless transactions.

### UserOperation v0.7

```java
import io.t402.erc4337.UserOperation;

// Use builder pattern for v0.7
UserOperation userOp = new UserOperation.Builder()
    .sender("0xSmartAccountAddress")
    .nonce(BigInteger.ZERO)
    .callData(callData)
    .callGasLimit(BigInteger.valueOf(100000))
    .verificationGasLimit(BigInteger.valueOf(100000))
    .preVerificationGas(BigInteger.valueOf(50000))
    .maxFeePerGas(maxFeePerGas)
    .maxPriorityFeePerGas(maxPriorityFeePerGas)
    .build();

// Compute UserOperation hash for signing
byte[] userOpHash = userOp.getUserOpHash(
    UserOperation.ENTRYPOINT_V07,  // 0x0000000071727De22E5E9d8BAf0edAc6f37da032
    chainId
);

// Pack for v0.7 RPC format
UserOperation.PackedUserOperation packed = userOp.pack();
```

### Safe Smart Account (v1.1.0+)

```java
import io.t402.erc4337.safe.SafeAccount;
import io.t402.erc4337.safe.SafeCall;
import io.t402.erc4337.safe.Operation;

// Create Safe account
SafeAccount safe = new SafeAccount(
    safeAddress,
    ownerAddress,
    chainId
);

// Encode single call
byte[] callData = safe.encodeExecTransaction(
    targetAddress,
    value,
    data,
    Operation.CALL
);

// Batch multiple calls
List<SafeCall> calls = List.of(
    new SafeCall(token1, BigInteger.ZERO, approveData, Operation.CALL),
    new SafeCall(token2, BigInteger.ZERO, transferData, Operation.CALL)
);
byte[] batchData = safe.encodeBatchCalls(calls);

// Create init code for new Safe deployment
byte[] initCode = safe.createInitCode(owners, threshold);

// Sign Safe transaction
byte[] txHash = safe.getSafeTransactionHash(to, value, data, operation, nonce);
byte[] signature = safe.signSafeTransaction(txHash, ownerPrivateKey);
```

### Bundler Providers (v1.1.0+)

```java
import io.t402.erc4337.bundler.*;

// Create bundler using factory
Bundler bundler = BundlerFactory.create(
    BundlerProvider.PIMLICO,
    "your-api-key",
    chainId
);

// Or create specific bundler directly
PimlicoBundler pimlico = new PimlicoBundler("api-key", chainId);
AlchemyBundler alchemy = new AlchemyBundler("api-key", chainId);
```

### Pimlico Bundler (v1.1.0+)

```java
import io.t402.erc4337.bundler.PimlicoBundler;

PimlicoBundler bundler = new PimlicoBundler(apiKey, chainId);

// Get gas prices (slow/standard/fast)
GasPrices prices = bundler.getUserOperationGasPrice();
userOp.setMaxFeePerGas(prices.getFast().getMaxFeePerGas());

// Sponsor with Pimlico paymaster
SponsorResult sponsor = bundler.sponsorUserOperation(userOp, entryPoint);
userOp.setPaymaster(sponsor.getPaymaster());
userOp.setPaymasterData(sponsor.getPaymasterData());
userOp.setPaymasterVerificationGasLimit(sponsor.getPaymasterVerificationGasLimit());
userOp.setPaymasterPostOpGasLimit(sponsor.getPaymasterPostOpGasLimit());

// Validate sponsorship policies
boolean valid = bundler.validateSponsorshipPolicies(policyIds);

// Get account nonce from bundler
BigInteger nonce = bundler.getAccountNonce(sender, key);
```

### Alchemy Bundler (v1.1.0+)

```java
import io.t402.erc4337.bundler.AlchemyBundler;

AlchemyBundler bundler = new AlchemyBundler(apiKey, chainId);

// Get gas and paymaster data in one call
GasAndPaymasterResult result = bundler.requestGasAndPaymasterAndData(
    userOp,
    entryPoint,
    policyId
);

// Simulate UserOperation for error checking
SimulationResult sim = bundler.simulateUserOperation(userOp, entryPoint);
if (!sim.isSuccess()) {
    System.err.println("Simulation failed: " + sim.getError());
}

// Get current priority fee
BigInteger priorityFee = bundler.getMaxPriorityFeePerGas();
```

### Generic Bundler Client

```java
import io.t402.erc4337.BundlerClient;

BundlerClient bundler = new BundlerClient("https://bundler.example.com");

// Estimate gas
GasEstimate estimate = bundler.estimateUserOperationGas(userOp, entryPoint);

// Submit UserOperation
String userOpHash = bundler.sendUserOperation(userOp, entryPoint);

// Get receipt
UserOperationReceipt receipt = bundler.getUserOperationReceipt(userOpHash);
```

## USDT0 Cross-Chain Bridge

Bridge USDT0 between chains using LayerZero.

```java
import io.t402.bridge.Usdt0Bridge;
import io.t402.bridge.BridgeTypes.*;

// Create bridge client
Usdt0Bridge bridge = new Usdt0Bridge();

// Get quote for bridging
BridgeQuote quote = bridge.getQuote(
    "eip155:1",        // Source chain (Ethereum)
    "eip155:42161",    // Destination chain (Arbitrum)
    "1000000000",      // Amount (1000 USDT0)
    "0xRecipient"      // Recipient address
);

// Execute bridge with signer
BridgeResult result = bridge.execute(quote, signer);

// Track message status
LayerZeroScanClient lzScan = new LayerZeroScanClient();
MessageStatus status = lzScan.getMessageStatus(result.getMessageHash());
```

### Supported Bridge Routes

| Source | Destination | Status |
|--------|-------------|--------|
| Ethereum | Arbitrum | ✅ |
| Ethereum | Ink | ✅ |
| Ethereum | Berachain | ✅ |
| Ethereum | Unichain | ✅ |
| Arbitrum | Ethereum | ✅ |
| Arbitrum | Ink | ✅ |

## WDK Integration

Integration with Tether Wallet Development Kit.

```java
import io.t402.wdk.WDKSigner;
import io.t402.wdk.WDKChains;
import io.t402.wdk.WDKTypes.*;

// Create signer from BIP-39 mnemonic
WDKSigner signer = WDKSigner.fromMnemonic(
    "your twelve word mnemonic phrase here..."
);

// Get chain configuration
ChainConfig config = WDKChains.getConfig("eip155:8453");

// Get token address
String usdtAddress = WDKChains.getTokenAddress("eip155:8453", "USDT");
```

## CLI Tool

The SDK includes a command-line interface.

```bash
# Run CLI via Maven
mvn exec:java -Dexec.mainClass="io.t402.cli.T402Cli" -Dexec.args="--help"

# Or build and run
java -jar t402-1.1.0.jar --help
```

### Available Commands

| Command | Description |
|---------|-------------|
| `verify` | Verify a payment payload |
| `settle` | Settle a verified payment |
| `supported` | List supported networks and schemes |
| `encode` | Encode a payment payload |
| `decode` | Decode a payment payload |
| `info` | Show SDK version and info |

### Examples

```bash
# Verify a payment
t402 verify --payload '{"x-payment": "..."}' --facilitator https://facilitator.t402.io

# List supported networks
t402 supported --json

# Decode payment header
t402 decode --header "eyJ0NDAyVmVyc2lvbiI6..."
```

## Client Usage

### Making Payment Requests

```java
import io.t402.client.T402HttpClient;

// Create HTTP client with signer
T402HttpClient client = new T402HttpClient(signer);

// Make a payment request
BigInteger amount = BigInteger.valueOf(1_000_000); // 1 USDC
HttpResponse<String> response = client.get(
    URI.create("https://api.example.com/premium"),
    amount,
    "0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913",  // Asset
    "0xReceiverAddress"                             // Pay to
);
```

### Manual Signing

```java
import io.t402.crypto.EvmSigner;

// Build authorization payload
Map<String, Object> payload = new HashMap<>();
payload.put("from", signer.getAddress());
payload.put("to", "0xRecipientAddress");
payload.put("value", "1000000");
payload.put("validAfter", "0");
payload.put("validBefore", String.valueOf(System.currentTimeMillis() / 1000 + 3600));
payload.put("nonce", generateRandomNonce());

// Sign with EIP-712
String signature = signer.sign(payload);
```

## Supported Networks

### EVM Networks

| Network | Chain ID | CAIP-2 Identifier |
|---------|----------|-------------------|
| Ethereum Mainnet | 1 | `eip155:1` |
| Base | 8453 | `eip155:8453` |
| Base Sepolia | 84532 | `eip155:84532` |
| Arbitrum One | 42161 | `eip155:42161` |
| Optimism | 10 | `eip155:10` |
| Polygon | 137 | `eip155:137` |
| Ink | 57073 | `eip155:57073` |
| Berachain | 80094 | `eip155:80094` |
| Unichain | 130 | `eip155:130` |

### Other Networks

| Network | Identifier |
|---------|------------|
| Solana Mainnet | `solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp` |
| Solana Devnet | `solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1` |
| TON Mainnet | `ton:mainnet` |
| TON Testnet | `ton:testnet` |
| TRON Mainnet | `tron:mainnet` |
| TRON Nile | `tron:nile` |
| TRON Shasta | `tron:shasta` |

## API Reference

### Core Classes

| Class | Description |
|-------|-------------|
| `T402HttpClient` | HTTP client with automatic payment header handling |
| `PaymentFilter` | Jakarta Servlet filter for payment-protected endpoints |
| `FacilitatorClient` | Interface for facilitator communication |
| `HttpFacilitatorClient` | HTTP implementation of FacilitatorClient |

### Crypto Classes

| Class | Description |
|-------|-------------|
| `CryptoSigner` | Interface for signing payment payloads |
| `EvmSigner` | EIP-3009 signing for EVM chains |
| `SvmSigner` | Ed25519 signing for Solana |
| `TonSigner` | Ed25519 signing for TON |
| `TronSigner` | ECDSA secp256k1 signing for TRON |

### ERC-4337 Classes

| Class | Description |
|-------|-------------|
| `UserOperation` | ERC-4337 v0.7 UserOperation with `pack()` and `getUserOpHash()` |
| `UserOperation.Builder` | Builder pattern for UserOperation creation |
| `SafeAccount` | Safe smart account integration (v1.1.0+) |
| `SafeCall` | Individual call for batch transactions |
| `Operation` | CALL vs DELEGATECALL enum |
| `BundlerClient` | Generic bundler JSON-RPC client |
| `PimlicoBundler` | Pimlico bundler with gas sponsorship (v1.1.0+) |
| `AlchemyBundler` | Alchemy bundler with simulation (v1.1.0+) |
| `BundlerFactory` | Factory for creating bundler instances |
| `BundlerProvider` | PIMLICO, ALCHEMY, CUSTOM enum |
| `GasEstimate` | Gas estimation types |

### Bridge Classes

| Class | Description |
|-------|-------------|
| `Usdt0Bridge` | LayerZero OFT bridge client |
| `LayerZeroScanClient` | Message tracking |
| `BridgeConstants` | Chain endpoints and addresses |

### WDK Classes

| Class | Description |
|-------|-------------|
| `WDKSigner` | BIP-39 seed derivation signer |
| `WDKChains` | Chain configuration |
| `WDKTypes` | Configuration and payment types |

### Spring Boot

| Class | Description |
|-------|-------------|
| `T402AutoConfiguration` | Auto-configuration for Spring Boot |
| `T402Properties` | Configuration properties (`t402.*`) |
| `RequirePayment` | Annotation for payment protection (v1.1.0+) |
| `RouteConfig` | YAML-based route configuration (v1.1.0+) |
| `PaymentInterceptor` | HandlerInterceptor for annotation-based validation (v1.1.0+) |
| `T402WebMvcConfigurer` | Auto-registers PaymentInterceptor (v1.1.0+) |

### Spring WebFlux (v1.1.0+)

| Class | Description |
|-------|-------------|
| `PaymentWebFilter` | WebFilter for reactive WebFlux applications |
| `T402WebFluxConfiguration` | Auto-configuration for WebFlux |

### Models

| Class | Description |
|-------|-------------|
| `PaymentPayload` | Payment header structure with Builder (v1.1.0+) |
| `PaymentRequirements` | Payment requirements for an endpoint |
| `ResourceInfo` | Resource metadata for v2 protocol (v1.1.0+) |
| `SupportedResponse` | Full /supported endpoint response (v1.1.0+) |
| `Authorization` | EIP-3009 authorization structure |
| `VerificationResponse` | Facilitator verification response |
| `SettlementResponse` | Facilitator settlement response |

## Configuration Properties

| Property | Description | Default |
|----------|-------------|---------|
| `t402.enabled` | Enable T402 integration | `false` |
| `t402.facilitator-url` | Facilitator service URL | `https://facilitator.t402.io` |
| `t402.network` | Network identifier (CAIP-2) | `eip155:8453` |
| `t402.pay-to` | Payment receiver address | - |
| `t402.asset` | Token contract address | - |
| `t402.token-name` | EIP-712 token name | `USD Coin` |
| `t402.token-version` | EIP-712 token version | `2` |
| `t402.scheme` | Payment scheme | `exact` |
| `t402.max-timeout-seconds` | Max payment timeout | `3600` |

## Error Handling

### Payment Required (402)

When payment is required but not provided:

```json
{
  "t402Version": 2,
  "accepts": [
    {
      "scheme": "exact",
      "network": "eip155:8453",
      "amount": "1000000",
      "asset": "0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913",
      "payTo": "0xReceiverAddress"
    }
  ],
  "error": "missing payment header"
}
```

### Verification Failed

```json
{
  "error": "Payment verification failed: invalid signature"
}
```

## Requirements

- Java 17+
- Jakarta Servlet API 6.0+ (for servlet filter)
- Spring Boot 3.x (for auto-configuration)

## Dependencies

The SDK includes:
- [Web3j](https://github.com/web3j/web3j) - Ethereum library for EIP-712 signing
- [Jackson](https://github.com/FasterXML/jackson) - JSON processing
- [TweetNaCl](https://github.com/AlicanAkkworlds/tweetnacl-java) - Ed25519 for Solana/TON
- Spring Boot (optional) - Auto-configuration support

## Resources

- [GitHub Repository](https://github.com/t402-io/t402/tree/main/java)
- [Maven Central](https://central.sonatype.com/artifact/io.t402/t402)
- [Changelog](https://github.com/t402-io/t402/blob/main/java/CHANGELOG.md)
- [API Javadoc](https://javadoc.io/doc/io.t402/t402)
