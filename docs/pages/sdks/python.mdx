# Python SDK

The T402 Python SDK provides comprehensive support for HTTP-native stablecoin payments.

## Installation

```bash
pip install t402
```

## Features

- **Multi-Chain Support**: EVM, TON, TRON, Solana
- **Server Middleware**: FastAPI and Flask integrations
- **Client Libraries**: httpx and requests adapters
- **ERC-4337**: Gasless payments with smart accounts
- **USDT0 Bridge**: LayerZero cross-chain bridging
- **WDK**: Tether Wallet Development Kit

## Quick Start

### Server (FastAPI)

```python
from fastapi import FastAPI
from t402.fastapi.middleware import require_payment

app = FastAPI()

app.middleware("http")(
    require_payment(
        price="0.01",
        pay_to_address="0x209693Bc6afc0C5328bA36FaF03C514EF312287C"
    )
)

@app.get("/")
async def root():
    return {"message": "Premium content!"}
```

### Client (httpx)

```python
from eth_account import Account
from t402.clients.httpx import t402HttpxClient

account = Account.from_key("your_private_key")

async with t402HttpxClient(account=account) as client:
    response = await client.get("https://api.example.com/protected")
    print(await response.aread())
```

## Modules

| Module | Description |
|--------|-------------|
| `t402` | Core types and utilities |
| `t402.ton` | TON blockchain support |
| `t402.tron` | TRON blockchain support |
| `t402.erc4337` | ERC-4337 account abstraction |
| `t402.bridge` | USDT0 cross-chain bridge |
| `t402.wdk` | Tether WDK integration |
| `t402.fastapi` | FastAPI middleware |
| `t402.flask` | Flask middleware |
| `t402.clients.httpx` | httpx client adapter |
| `t402.clients.requests` | requests adapter |

## Server Integrations

### FastAPI

```python
from fastapi import FastAPI
from t402.fastapi.middleware import require_payment

app = FastAPI()

# Protect all routes
app.middleware("http")(
    require_payment(
        price="0.01",
        pay_to_address="0x..."
    )
)

# Protect specific routes
app.middleware("http")(
    require_payment(
        price="0.001",
        pay_to_address="0x...",
        path=["/api/premium", "/api/exclusive"]
    )
)
```

### Flask

```python
from flask import Flask
from t402.flask.middleware import PaymentMiddleware

app = Flask(__name__)
payment = PaymentMiddleware(app)

# Protect all routes
payment.add(
    price="$0.01",
    pay_to_address="0x..."
)

# Protect specific routes
payment.add(
    path="/api/premium",
    price="$0.001",
    pay_to_address="0x..."
)
```

## Client Integrations

### httpx (Async)

```python
from eth_account import Account
from t402.clients.httpx import t402HttpxClient

account = Account.from_key("0x...")

async with t402HttpxClient(account=account) as client:
    response = await client.get("https://api.example.com/protected")
```

### requests (Sync)

```python
from eth_account import Account
from t402.clients.requests import t402_requests

account = Account.from_key("0x...")
session = t402_requests(account)

response = session.get("https://api.example.com/protected")
```

## Multi-Chain Support

### TON

```python
from t402 import (
    TON_MAINNET,
    TON_TESTNET,
    validate_ton_address,
    get_ton_network_config,
)

config = get_ton_network_config(TON_MAINNET)
is_valid = validate_ton_address("EQD...")
```

### TRON

```python
from t402 import (
    TRON_MAINNET,
    TRON_NILE,
    validate_tron_address,
    get_tron_network_config,
)

config = get_tron_network_config(TRON_MAINNET)
is_valid = validate_tron_address("T...")
```

### Solana (SVM)

```python
from t402 import (
    SOLANA_MAINNET,
    SOLANA_DEVNET,
    SOLANA_TESTNET,
    validate_svm_address,
    get_svm_network_config,
    get_svm_usdc_address,
    is_svm_network,
)

# Validate address
is_valid = validate_svm_address("EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v")

# Get network config
config = get_svm_network_config(SOLANA_MAINNET)

# Get USDC mint address
usdc_mint = get_svm_usdc_address(SOLANA_MAINNET)

# Check if network is Solana
is_solana = is_svm_network("solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp")
```

Install with optional Solana dependencies:

```bash
pip install t402[svm]
```

## ERC-4337 Account Abstraction

Gasless payments using smart accounts:

```python
from t402 import (
    create_bundler_client,
    create_paymaster,
    create_smart_account,
    SafeAccountConfig,
)

# Create bundler
bundler = create_bundler_client(
    bundler_type="pimlico",
    api_key="your_api_key",
    chain_id=8453
)

# Create paymaster for sponsored txs
paymaster = create_paymaster(
    paymaster_type="pimlico",
    api_key="your_api_key",
    chain_id=8453
)

# Create Safe smart account
account = create_smart_account(
    config=SafeAccountConfig(
        owner_private_key="0x...",
        chain_id=8453,
    ),
    bundler=bundler,
    paymaster=paymaster,
)
```

## USDT0 Cross-Chain Bridge

Bridge USDT0 across chains using LayerZero:

```python
from t402 import (
    create_usdt0_bridge,
    create_cross_chain_payment_router,
    get_bridgeable_chains,
)

# Check supported chains
chains = get_bridgeable_chains()

# Create bridge client
bridge = create_usdt0_bridge(
    private_key="0x...",
    source_chain_id=1,  # Ethereum
)

# Get quote before bridging
quote = await bridge.get_quote(
    destination_chain_id=8453,  # Base
    amount="1000000",  # 1 USDT0
)
print(f"Fee: {quote.fee}, ETA: {quote.estimated_time}")

# Execute bridge
result = await bridge.bridge(
    destination_chain_id=8453,  # Base
    amount="1000000",  # 1 USDT0
    recipient="0x...",
)
print(f"Transaction: {result.transaction_hash}")
```

## WDK Integration

Tether Wallet Development Kit support:

```python
from t402 import (
    WDKSigner,
    generate_seed_phrase,
    WDKConfig,
    get_wdk_usdt0_chains,
)

# Generate new wallet
seed = generate_seed_phrase()

# Create WDK signer with multi-chain support
signer = WDKSigner(
    config=WDKConfig(
        seed_phrase=seed,
        chains=get_wdk_usdt0_chains(),
    )
)

# Get address for specific chain
address = await signer.get_address(chain_id=8453)
print(f"Base address: {address}")

# Sign payment
signature = await signer.sign_payment(
    chain_id=8453,
    amount="1000000",
    recipient="0x...",
)
```

## Advanced Client Usage

### httpx Extensible Example

Use t402 hooks with any httpx client:

```python
import httpx
from eth_account import Account
from t402.clients.httpx import t402_payment_hooks

# Initialize account
account = Account.from_key("your_private_key")

# Create httpx client with t402 payment hooks
async with httpx.AsyncClient(base_url="https://api.example.com") as client:
    # Add payment hooks directly to client
    client.event_hooks = t402_payment_hooks(account)

    # Make request - payment handling is automatic
    response = await client.get("/protected-endpoint")
    print(await response.aread())
```

### requests Session Extensible Example

Use t402 adapter with any requests session:

```python
import requests
from eth_account import Account
from t402.clients.requests import t402_http_adapter

# Initialize account
account = Account.from_key("your_private_key")

# Create session and mount the t402 adapter
session = requests.Session()
adapter = t402_http_adapter(account)

# Mount the adapter for both HTTP and HTTPS
session.mount("http://", adapter)
session.mount("https://", adapter)

# Make request - payment handling is automatic
response = session.get("https://api.example.com/protected-endpoint")
print(response.content)
```

## Manual Server Integration

If you're not using the FastAPI/Flask middleware, you can implement the t402 protocol manually:

```python
from typing import Annotated
from fastapi import FastAPI, Request
from fastapi.responses import JSONResponse
from t402.types import PaymentRequiredResponse, PaymentRequirements, PaymentPayload
from t402.encoding import safe_base64_decode
from t402 import FacilitatorClient, FacilitatorConfig
import base64
import json

app = FastAPI()

# Configure payment requirements
payment_requirements = PaymentRequirements(
    scheme="exact",
    network="eip155:8453",
    max_amount_required="10000",
    asset="0x833589fCD6eDb6E08f4c7C32D4f71b54bda02913",
    pay_to="0x209693Bc6afc0C5328bA36FaF03C514EF312287C",
)

# Create facilitator client
facilitator = FacilitatorClient(FacilitatorConfig(
    url="https://facilitator.t402.io"
))

@app.get("/protected")
async def protected_endpoint(request: Request):
    payment_required = PaymentRequiredResponse(
        t402_version=2,
        accepts=[payment_requirements],
        error="",
    )

    # Check for payment header
    payment_header = request.headers.get("X-PAYMENT", "")

    if payment_header == "":
        payment_required.error = "X-PAYMENT header not set"
        return JSONResponse(
            content=payment_required.model_dump(by_alias=True),
            status_code=402,
        )

    # Decode and parse payment
    try:
        payment = PaymentPayload(**json.loads(safe_base64_decode(payment_header)))
    except Exception as e:
        payment_required.error = f"Invalid payment format: {str(e)}"
        return JSONResponse(
            content=payment_required.model_dump(by_alias=True),
            status_code=402,
        )

    # Verify payment
    verify_response = await facilitator.verify(payment, payment_requirements)
    if not verify_response.is_valid:
        payment_required.error = f"Invalid payment: {verify_response.invalid_reason}"
        return JSONResponse(
            content=payment_required.model_dump(by_alias=True),
            status_code=402,
        )

    # Settle payment
    settle_response = await facilitator.settle(payment, payment_requirements)
    if not settle_response.success:
        payment_required.error = f"Settlement failed: {settle_response.error_reason}"
        return JSONResponse(
            content=payment_required.model_dump(by_alias=True),
            status_code=402,
        )

    # Return success with settlement header
    response = JSONResponse(
        content={"message": "Premium content!", "data": "..."},
        status_code=200,
    )
    response.headers["X-PAYMENT-RESPONSE"] = base64.b64encode(
        settle_response.model_dump_json().encode("utf-8")
    ).decode("utf-8")

    return response
```

## Error Handling

### Client-Side Error Handling

```python
from t402.clients.httpx import t402HttpxClient
from t402.exceptions import PaymentError, InsufficientFundsError

account = Account.from_key("your_private_key")

async with t402HttpxClient(account=account) as client:
    try:
        response = await client.get("https://api.example.com/protected")
        data = await response.aread()
    except InsufficientFundsError as e:
        print(f"Not enough balance: {e}")
    except PaymentError as e:
        print(f"Payment failed: {e}")
```

### Server-Side Error Handling

```python
from t402.fastapi.middleware import require_payment, PaymentErrorHandler

def custom_error_handler(request, error):
    # Custom logging or metrics
    logger.error(f"Payment error: {error}")
    return JSONResponse(
        content={"error": str(error)},
        status_code=402
    )

app.middleware("http")(
    require_payment(
        price="0.01",
        pay_to_address="0x...",
        error_handler=custom_error_handler
    )
)
```

## Async Patterns

### Concurrent Requests

```python
import asyncio
from t402.clients.httpx import t402HttpxClient

account = Account.from_key("your_private_key")

async def fetch_multiple():
    async with t402HttpxClient(account=account) as client:
        urls = [
            "https://api.example.com/data1",
            "https://api.example.com/data2",
            "https://api.example.com/data3",
        ]

        # Make concurrent requests
        tasks = [client.get(url) for url in urls]
        responses = await asyncio.gather(*tasks)

        return [await r.aread() for r in responses]
```

### Connection Pooling

```python
from t402.clients.httpx import t402HttpxClient

# Configure connection limits
client = t402HttpxClient(
    account=account,
    limits=httpx.Limits(
        max_connections=100,
        max_keepalive_connections=20
    )
)
```

## Facilitator Client

```python
from t402 import FacilitatorClient, FacilitatorConfig

client = FacilitatorClient(FacilitatorConfig(
    url="https://facilitator.t402.io",
    timeout=30.0,
))

# Get supported networks
supported = await client.get_supported()
for kind in supported.kinds:
    print(f"Supported: {kind.network} - {kind.scheme}")

# Verify payment
result = await client.verify(payload, requirements)
if result.is_valid:
    print("Payment is valid")
else:
    print(f"Invalid: {result.invalid_reason}")

# Settle payment
result = await client.settle(payload, requirements)
if result.success:
    print(f"Transaction: {result.transaction}")
else:
    print(f"Failed: {result.error_reason}")
```

## API Reference

### Core Types

| Type | Description |
|------|-------------|
| `PaymentRequirements` | Payment configuration (scheme, network, amount, etc.) |
| `PaymentPayload` | Signed payment data |
| `VerifyResponse` | Verification result with `is_valid` flag |
| `SettleResponse` | Settlement result with transaction hash |
| `PaymentRequiredResponse` | 402 response body structure |

### Network Utilities

| Function | Description |
|----------|-------------|
| `is_evm_network(network)` | Check if network is EVM-compatible |
| `is_ton_network(network)` | Check if network is TON |
| `is_tron_network(network)` | Check if network is TRON |
| `is_svm_network(network)` | Check if network is Solana |
| `get_network_type(network)` | Get network type string |
| `validate_ton_address(addr)` | Validate TON address format |
| `validate_tron_address(addr)` | Validate TRON address format |
| `validate_svm_address(addr)` | Validate Solana address format |

### Configuration

```python
# FastAPI middleware options
require_payment(
    price="0.01",              # Price in USD (string or float)
    pay_to_address="0x...",    # Recipient address
    network="eip155:8453",     # Network identifier (default: Base)
    scheme="exact",            # Payment scheme (default: exact)
    path=None,                 # Path(s) to protect (None = all)
    facilitator_url=None,      # Custom facilitator URL
    error_handler=None,        # Custom error handler
)
```

## Requirements

- Python 3.10+
- pip or uv package manager
